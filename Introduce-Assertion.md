# Введение утверждения (Introduce Assertion)

Некоторая часть кода предполагает определенное состояние программы.

_Сделайте предположение явным с помощью оператора утверждения._

```java
double getExpenseLimit() {
    // should have either expense limit or a primary project
    return (_expenseLimit != NULL_EXPENSE)
        ? _expenseLimit : _primaryProject.getMemberExpenseLimit();
}
```

![](images/arrow.jpg)

```java
double getExpenseLimit() {
    Assert.isTrue (_expenseLimit != NULL_EXPENSE || _primaryProject != null);
    return (_expenseLimit != NULL_EXPENSE)
        ? _expenseLimit
        : _primaryProject.getMemberExpenseLimit();
}
```

## Мотивировка

Часто некоторые разделы кода могут работать, только если выполнены определенные условия. Простейшим примером служит вычисление квадратного корня, выполнимое, только если входное значение положительно. Для объекта это может быть предположение о том, что хотя бы одно поле в группе содержит значение.

Такие предположения часто не сформулированы и могут быть выявлены лишь при просмотре алгоритма. Иногда предположения относительно нормальных условий указаны в комментариях. Лучше всего, когда предположение формулируется явно в утверждении.

Утверждение (assertion) представляет собой условный оператор, который всегда должен выполняться. Отказ утверждения свидетельствует об ошибке в программе. Поэтому отказ утверждения должен всегда приводить к появлению необрабатываемых исключительных ситуаций. Утверждения никогда не должны использоваться другими частями системы. В действительности, утверждения обычно удаляются из готового кода. Поэтому важно сигнализировать о том, что нечто представляет собой утверждение.

Утверждения способствуют организации общения и отладки. Их коммуникативная роль состоит в том, что они помогают читателю понять, какие допущения делает код. Во время отладки утверждения помогают перехватывать ошибки ближе к источнику их возникновения. По моим наблюдениям, помощь для отладки невелика, если код самотестирующийся, но я ценю коммуникативную роль утверждений.

## Техника

Поскольку утверждения не должны оказывать влияния на работу системы, при их введении всегда сохраняется поведение.

* Когда вы видите, что предполагается выполненным некоторое условие, добавьте утверждение, в котором это явно формулируется.

_Используйте для организации поведения утверждения класс assert._

Не злоупотребляйте утверждениями. Не старайтесь с их помощью проверять все условия, которые, по вашему мнению, должны быть истинны в некотором фрагменте кода. Используйте утверждения только для проверки того, что _обязано_ быть истинным. Чрезмерное применение утверждений может привести к дублированию логики, что неудобно для сопровождения. Логика, охватывающая допущение, полезна, потому что заставляет заново обдумать часть кода. Если код работает без утверждения, то от последнего больше путаницы, чем пользы, а последующая модификация может быть затруднена.

Всегда проверяйте, будет ли работать код в случае отказа утверждения. Если да, то удалите утверждение.

Остерегайтесь дублирования кода в утверждениях. Дублирующийся код пахнет в них так же дурно, как во всех других местах. Не скупитесь применять «Выделение метода» ([Extract Method](Extract-Method.md)) для устранения дублирования.

## Пример

Вот простая история с предельными расходами. Служащим может назначаться индивидуальный предел расходов. Если они участвуют в основном проекте, то могут пользоваться предельными расходами этого основного проекта. У них необязательно должны быть предел расходов или основной проект, но одно из двух у них должен присутствовать обязательно. Данное допущение предполагается выполненным в коде, который учитывает пределы расходов:

```java
class Employee...
    private static final double NULL_EXPENSE = -1.0;
    private double _expenseLimit = NULL_EXPENSE;
    private Project _primaryProject;
    
    double getExpenseLimit() {
        return (_expenseLimit != NULL_EXPENSE)
            ? _expenseLimit
            : _primaryProject.getMemberExpenseLimit();
    }
    
    boolean withinLimit (double expenseAmount) {
        return (expenseAmount <= getExpenseLimit());
    }
```

В этом коде сделано неявное допущение, что у служащего есть предел расходов – либо проекта, либо персональный. В коде такое утверждение следует сформулировать явно:

```java
double getExpenseLimit() {
    Assert.isTrue (_expenseLimit != NULL_EXPENSE || _primaryProject != null);
    return (_expenseLimit != NULL_EXPENSE)
        ? _expenseLimit
        : _primaryProject.getMemberExpenseLimit();
}
```

Данное утверждение не меняет каких-либо аспектов поведения программы. В любом случае, если утверждение не выполнено, возникает исключительная ситуация на этапе исполнения: либо исключительная ситуация нулевого указателя в `withinLimit`, либо исключительная ситуация времени выполнения в `Assert.isTrue`. В некоторых ситуациях утверждение помогает обнаружить ошибку, потому что оно ближе находится к тому месту, где она возникла. Однако в основном утверждение сообщает о том, как работает код и какие предположения в нем сделаны.

Я часто применяю «Выделение метода» ([Extract Method](Extract-Method.md)) к условному выражению внутри утверждения. С его помощью либо устраняется дублирование кода, либо проясняется смысл условия.

Одна из сложностей применения утверждений в Java связана с отсутствием простого механизма их вставки. Утверждения должны легко удаляться, чтобы не оказывать влияния на выполнение готового кода. Конечно, наличие такого вспомогательного класса, как `Assert`, облегчает положение. К сожалению, что бы ни случилось, выполняются все выражения внутри параметров утверждения. Единственным способом не допустить этого является код следующего типа:

```java
double getExpenseLimit() {
    Assert.isTrue (Assert.ON && (_expenseLimit != NULL_EXPENSE || _primaryProject != null));
    return (_expenseLimit != NULL_EXPENSE)
        ? _expenseLimit
        : _primaryProject.getMemberExpenseLimit();
}
```

или

```java
double getExpenseLimit() {
    if (Assert.ON)
        Assert.isTrue (_expenseLimit != NULL_EXPENSE || _primaryProject != null);
    return (_expenseLimit != NULL_EXPENSE)
        ? _expenseLimit
        : _primaryProject.getMemberExpenseLimit();
}
```

Если `Assert.ON` представляет собой константу, компилятор должен обнаружить и удалить мертвый код при ложном ее значении. Однако добавление условного предложения запутывает код, и многие программисты предпочитают использовать просто `Assert`, а затем, при создании готового кода, отфильтровывать все строки, в которых есть `assert` (например, с помощью Perl).

В классе `Assert` должны быть разные методы с удобными именами. Помимо `isTrue` в нем может присутствовать `equals` и `shouldNeverReachHere` (сюда вы никогда не должны попасть).