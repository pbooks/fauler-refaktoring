# Сохранение всего объекта (Preserve Whole Object)

Вы получаете от объекта несколько значений, которые затем передаете как параметры при вызове метода.

_Передавайте вместо этого весь объект._

```java
int low = daysTempRange().getLow();
int high = daysTempRange().getHigh();
withinPlan = plan.withinRange(low, high);
```

![](images/arrow.jpg)

```java
withinPlan = plan.withinRange(daysTempRange());
```

## Мотивировка

Такого рода ситуация возникает, когда объект передает несколько значений данных из одного объекта как параметры в вызове метода. Проблема заключается в том, что если вызываемому объекту в дальнейшем потребуются новые данные, придется найти и изменить все вызовы этого метода. Этого можно избежать, если передавать весь объект, от которого поступают данные. В этом случае вызываемый объект может запрашивать любые необходимые ему данные от объекта в целом.

Помимо того что список параметров становится более устойчив к изменениям, «Сохранение всего объекта» ([Preserve Whole Object](Preserve-Whole-Object.md)) часто улучшает читаемость кода. С длинными списками параметров бывает трудно работать, потому что как вызывающий, так и вызываемый объект должны помнить, какие в нем были значения. Они также способствуют дублированию кода, потому что вызываемый объект не может воспользоваться никакими другими методами всего объекта для вычисления промежуточных значений.

Существует, однако, и обратная сторона. При передаче значений вызванный объект зависит от значений, но не зависит от объекта, из которого извлекаются эти значения. Передача необходимого объекта устанавливает зависимость между ним и вызываемым объектом. Если это запутывает имеющуюся структуру зависимостей, не применяйте «Сохранение всего объекта» ([Preserve Whole Object](Preserve-Whole-Object.md)).

Другая причина, по которой, как говорят, не стоит применять «Сохранение всего объекта» ([Preserve Whole Object](Preserve-Whole-Object.md)), заключается в том, что если вызывающему объекту нужно только одно значение необходимого объекта, лучше передавать это значение, а не весь объект. Я не согласен с такой точкой зрения. Передачи одного значения и одного объекта равнозначны, по крайней мере, в отношении ясности (передача параметров по значению может потребовать дополнительных накладных расходов). Движущей силой здесь является проблема зависимости.

То, что вызываемому методу нужно много значений от другого объекта, указывает на то, что в действительности этот метод должен быть определен в том объекте, который дает ему значения. Применяя «Сохранение всего объекта» ([Preserve Whole Object](Preserve-Whole-Object.md)), рассмотрите в качестве возможной альтернативы «Перемещение метода» ([Move Method](Move-Method.md)).

Может оказаться, что целый объект пока не определен. Тогда необходимо «Введение граничного объекта» ([Introduce Parameter Object](Introduce-Parameter-Object.md)).

Часто бывает, что вызывающий объект передает в качестве параметров несколько значений _своих_ собственных данных. В таком случае можно вместо этих значений передать в вызове `this`, если имеются соответствующие методы получения значений и нет возражений против возникающей зависимости.

## Техника

* Создайте новый параметр для передачи всего объекта, от которого поступают данные.
* Выполните компиляцию и тестирование.
* Определите, какие параметры должны быть получены от объекта в целом.
* Возьмите один параметр и замените ссылки на него в теле метода вызовами соответствующего метода всего объекта параметра.
* Удалите ненужный параметр.
* Выполните компиляцию и тестирование.
* Повторите эти действия для каждого параметра, который можно получить от передаваемого объекта.
* Удалите из вызывающего метода код, который получает удаленные параметры.

_Конечно, в том случае, когда код не использует эти параметры в каком нибудь другом месте._

* Выполните компиляцию и тестирование.

## Пример

Рассмотрим объект, представляющий помещение и регистрирующий самую высокую и самую низкую температуру в течение суток. Он должен сравнивать этот диапазон с диапазоном в заранее установленном плане обогрева:

```java
class Room...
    boolean withinPlan(HeatingPlan plan) {
        int low = daysTempRange().getLow();
        int high = daysTempRange().getHigh();
        return plan.withinRange(low, high);
    }
    
class HeatingPlan...
    boolean withinRange (int low, int high) {
        return (low >= _range.getLow() && high <= _range.getHigh());
    }
    
    private TempRange _range;
```

Вместо распаковки данных диапазона для их передачи я могу передать целиком объект `Range`. В данном простом случае это можно сделать за один шаг. Если бы участвовало больше параметров, можно было бы действовать небольшими шагами. Сначала я добавляю в список параметров объект, от которого буду получать необходимые данные:

```java
class HeatingPlan...
    boolean withinRange (TempRange roomRange, int low, int high) {
        return (low >= _range.getLow() && high <= _range.getHigh());
    }
   
class Room...
    boolean withinPlan(HeatingPlan plan) {
        int low = daysTempRange().getLow();
        int high = daysTempRange().getHigh();
        return plan.withinRange(daysTempRange(), low, high);
    }
```

Затем я применяю метод ко всему объекту, а не к одному из параметров:

```java
class HeatingPlan...
    boolean withinRange (TempRange roomRange, int high) {
        return (roomRange.getLow() >= _range.getLow() && high <= _range.getHigh());
    }
   
class Room...
    boolean withinPlan(HeatingPlan plan) {
        int low = daysTempRange().getLow();
        int high = daysTempRange().getHigh();
        return plan.withinRange(daysTempRange(), high);
    }
```

Продолжаю, пока не заменю все, что требуется:

```java
class HeatingPlan...
    boolean withinRange (TempRange roomRange) {
        return (roomRange.getLow() >= _range.getLow() && roomRange.getHigh() <= _range.getHigh());
    }
    
class Room...
    boolean withinPlan(HeatingPlan plan) {
        int low = daysTempRange().getLow();
        int high = daysTempRange().getHigh();
        return plan.withinRange(daysTempRange());
    }
```

Временные переменные мне больше не нужны:

```java
class Room...
    boolean withinPlan(HeatingPlan plan) {
        return plan.withinRange(daysTempRange());
    }
```

Такое применение целых объектов вскоре позволяет понять, что полезно переместить поведение в целый объект, т. к. это облегчит работу с ним.

```java
class HeatingPlan...
    boolean withinRange (TempRange roomRange) {
        return (_range.includes(roomRange));
    }
    
class TempRange...
    boolean includes (TempRange arg) {
        return arg.getLow() >= this.getLow() && arg.getHigh() <= this.getHigh();
    }
```