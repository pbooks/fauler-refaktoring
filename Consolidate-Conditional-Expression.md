# Консолидация условного выражения (Consolidate Conditional Expression)

Есть ряд проверок условия, дающих одинаковый результат.

_Объедините их в одно условное выражение и выделите его._

```java
double disabilityAmount() {
    if (_seniority < 2) return 0;
    if (_monthsDisabled > 12) return 0;
    if (_isPartTime) return 0;
    // compute the disability amount
```
![alt tag](/images/arrow.jpg)
```java
double disabilityAmount() {
    if (isNotEligableForDisability()) return 0;
    // compute the disability amount
```

## Мотивировка

Иногда встречается ряд проверок условий, в котором все проверки различны, но результирующее действие одно и то же. Встретившись с этим, необходимо с помощью логических операций «и»/«или» объединить проверки в одну проверку условия, возвращающую один результат.

Объединение условного кода важно по двум причинам. Во первых, проверка становится более ясной, показывая, что в действительности проводится одна проверка, в которой логически складываются результаты других. Последовательность имеет тот же результат, но говорит о том, что выполняется ряд отдельных проверок, которые случайно оказались вместе. Второе основание для проведения этого рефакторинга состоит в том, что он часто подготавливает почву для «Выделения метода» ([Extract Method](/Extract-Method.md)). Выделение условия – одно из наиболее полезных для прояснения кода действий. Оно заменяет изложение выполняемых действий причиной, по которой они выполняются.

Основания в пользу консолидации условных выражений указывают также на причины, по которым ее выполнять не следует. Если вы считаете, что проверки действительно независимы и не должны рассматриваться как одна проверка, не производите этот рефакторинг. Имеющийся код уже раскрывает ваш замысел.

## Техника

* Убедитесь, что условные выражения не несут побочных эффектов.

_Если побочные эффекты есть, вы не сможете выполнить этот рефакторинг._

* Замените последовательность условий одним условным предложением с помощью логических операторов.
* Выполните компиляцию и тестирование.
* Изучите возможность применения к условию «Выделения метода» ([Extract Method](/Extract-Method.md)).

## Пример: логическое «или»

Имеется следующий код:

```java
double disabilityAmount() {
    if (_seniority < 2) return 0;
    if (_monthsDisabled > 12) return 0;
    if (_isPartTime) return 0;
    // вычислить сумму оплаты по нетрудоспособности
    ...
```
Мы видим ряд условных операторов, возвращающих одинаковый результат. Для кода в такой последовательности проверки эквивалентны предложению с операцией «или»:

```java
double disabilityAmount() {
    if ((_seniority < 2) || (_monthsDisabled > 12) || (_isPartTime))
        return 0;
    // вычислить сумму оплаты по нетрудоспособности
    ...
```

Взгляд на условие показывает, что, применив «Выделение метода» ([Extract Method](/Extract-Method.md)), можно сообщить о том, что ищет условный оператор (нетрудоспособность не оплачивается):

```java
double disabilityAmount() {
    if (isNotEligibleForDisability()) return 0;
    // вычислить сумму оплаты по нетрудоспособности ...
}

boolean isNotEligibleForDisability() {
    return ((_seniority < 2) || (_monthsDisabled > 12) || (_isPartTime));
}
```

## Пример: логическое «и»

Предыдущий пример демонстрировал «или», но то же самое можно делать с помощью «и». Пусть ситуация выглядит так:

```java
if (onVacation())
    if (lengthOfService() > 10)
        return 1;
return 0.5;
```

Этот код надо заменить следующим:

```java
if (onVacation() && lengthOfService() > 10) return 1;
else return 0.5;
```

Часто получается комбинированное выражение, содержащее «и», «или» и «не». В таких случаях условия бывают запутанными, поэтому я стараюсь их упростить с помощью «Выделения метода» ([Extract Method](/Extract-Method.md)).

Если рассматриваемая процедура лишь проверяет условие и возвращает значение, я могу превратить ее в одно предложение `return` с помощью тернарного оператора, так что

```java
if (onVacation() && lengthOfService() > 10) return 1;
else return 0.5;
```

превращается в

```java
return (onVacation() && lengthOfService() > 10) ? 1 : 0.5;
```