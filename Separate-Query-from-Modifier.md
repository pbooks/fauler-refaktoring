# Разделение запроса и модификатора (Separate Query from Modifier)

Есть метод, возвращающий значение, но, кроме того, изменяющий состояние объекта.

_Создайте два метода – один для запроса и один для модификации._

![](images/Separate-Query-from-Modifier.jpg)

## Мотивировка

Если есть функция, которая возвращает значение и не имеет видимых побочных эффектов, это весьма ценно. Такую функцию можно вызывать сколь угодно часто. Ее вызов можно переместить в методе в другое место. Короче, с ней значительно меньше проблем.

Хорошая идея – четко проводить различие между методами с побочными эффектами и теми, у которых их нет. Полезно следовать правилу, что у любого метода, возвращающего значение, не должно быть наблюдаемых побочных эффектов. Некоторые программисты рассматривают это правило как абсолютное [Meyer]. Я не придерживаюсь его в 100% случаев (как и любых других правил), но в основном стараюсь его соблюдать, и оно служит мне верой и правдой.

Обнаружив метод, который возвращает значение, но также обладает побочными эффектами, следует попытаться разделить запрос и модификатор.

Возможно, вы обратили внимание на слова «_наблюдаемые_ побочные эффекты». Стандартная оптимизация заключается в кэшировании значения запроса в поле, чтобы повторные запросы выполнялись быстрее. Хотя при этом изменяется состояние объекта с кэшем, такое изменение не наблюдаемо. Любая последовательность запросов всегда возвращает одни и те же результаты для каждого запроса [Meyer].

## Техника

* Создайте запрос, возвращающий то же значение, что и исходный метод.

_Посмотрите, что возвращает исходный метод. Если возвращается значение временной переменной, найдите место, где ей присваивается значение._

* Модифицируйте исходный метод так, чтобы он возвращал результат обращения к запросу.

_Все return в исходном методе должны иметь вид `return newQuery()`._

_Если временная переменная использовалась в методе с единственной целью захватить возвращаемое значение, ее, скорее всего, можно удалить._

* Выполните компиляцию и тестирование.
* Для каждого вызова замените одно обращение к исходному методу вызовом запроса. Добавьте вызов исходного метода перед строкой с вызовом запроса. Выполняйте компиляцию и тестирование после каждого изменения вызова метода.
* Объявите для исходного метода тип возвращаемого значения `void` и удалите выражения `return`.

## Пример

Вот функция, которая сообщает мне для системы безопасности имя злодея и посылает предупреждение. Согласно имеющемуся правилу посылается только одно предупреждение, даже если злодеев несколько:

```java
String foundMiscreant(String[] people){
    for (int i = 0; i < people.length; i++) {
        if (people[i].equals ("Don")){
            sendAlert();
            return "Don";
        }
        if (people[i].equals ("John")){
            sendAlert();
            return "John";
        }
    }
    return "";
}
```

Вызов этой функции выполняется здесь:

```java
void checkSecurity(String[] people) {
    String found = foundMiscreant(people);
    someLaterCode(found);
}
```

Чтобы отделить запрос от модификатора, я должен сначала создать подходящий запрос, который возвращает то же значение, что и модификатор, но не создает побочных эффектов:

```java
String foundPerson(String[] people){
    for (int i = 0; i < people.length; i++) {
        if (people[i].equals ("Don")){
            return "Don";
        }
        if (people[i].equals ("John")){
            return "John";
        }
    }
    return "";
}
```

После этого я поочередно заменяю все return в исходной функции вызовами нового запроса. После каждой замены я провожу тестирование. В результате первоначальный метод принимает следующий вид:

```java
String foundMiscreant(String[] people){
    for (int i = 0; i < people.length; i++) {
        if (people[i].equals ("Don")){
            sendAlert();
            return foundPerson(people);
        }
        if (people[i].equals ("John")){
            sendAlert();
            return foundPerson(people);
        }
    }
    return foundPerson(people);
}
```

Теперь я изменю все методы, из которых происходит обращение, так чтобы в них происходило два вызова – сначала модификатора, а потом запроса:

```java
void checkSecurity(String[] people) {
    foundMiscreant(people);
    String found = foundPerson(people);
    someLaterCode(found);
}
```

Проделав это для всех вызовов, я могу установить для модификатора тип возвращаемого значения `void`:

```java
void foundMiscreant (String[] people){
    for (int i = 0; i < people.length; i++) {
        if (people[i].equals ("Don")){
            sendAlert();
            return;
        }
        if (people[i].equals ("John")){
            sendAlert();
            return;
        }
    }
}
```

Теперь, пожалуй, лучше изменить имя оригинала:

```java
void sendAlert (String[] people){
    for (int i = 0; i < people.length; i++) {
        if (people[i].equals ("Don")){
            sendAlert();
            return;
        }
        if (people[i].equals ("John")){
            sendAlert();
            return;
        }
    }
}
```

Конечно, в этом случае дублируется много кода, потому что модификатор пользуется для своей работы телом запроса. Я могу теперь применить к модификатору «Замещение алгоритма» ([Substitute Algorithm](Substitute-Algorithm.md)) и воспользоваться этим:

```java
void sendAlert(String[] people){
    if (! foundPerson(people).equals("")) sendAlert();
}
```

## Проблемы параллельного выполнения

Те, кто работает в многопоточной системе, знают, что выполнение операций проверки и установки как единого действия является важной идиомой. Влечет ли это конфликт с «Разделением запроса и модификатора» ([Separate Query from Modifier](Separate-Query-from-Modifier.md))? Я обсуждал эту проблему с Дагом Ли и пришел к выводу, что нет, но необходимо выполнить некоторые дополнительные действия. По-прежнему полезно разделить операции запроса и модификации, однако надо сохранить третий метод, осуществляющий и то и другое. Операция «запрос-модификация» должна вызывать отдельные методы запроса и модификации и синхронизироваться. Если операции запроса и модификации не синхронизированы, можно также ограничить их видимость пакетом или сделать закрытыми. Благодаря этому получается безопасная синхронизированная операция, разложенная на два более легко понимаемые метода. Эти два метода более низкого уровня могут применяться для других целей.