# Декомпозиция условного оператора (Decompose Conditional)

Имеется сложная условная цепочка проверок (if then else).

_Выделите методы из условия, части «then» и частей «else»._

```java
if (date.before (SUMMER_START) || date.after(SUMMER_END))
    charge = quantity * _winterRate + _winterServiceCharge;
else charge = quantity * _summerRate;
```
![alt tag](/images/arrow.jpg)
```java 
if (notSummer(date))
    charge = winterCharge(quantity);
else charge = summerCharge (quantity);
```

## Мотивировка

Очень часто сложность программы обусловлена сложностью условной логики. При написании кода, обязанного проверять условия и делать в зависимости от условий разные вещи, мы быстро приходим к созданию довольно длинного метода. Длина метода сама по себе осложняет его чтение, но если есть условные выражения, трудностей становится еще больше. Обычно проблема связана с тем, что код, как в проверках условий, так и в действиях, говорит о том, что происходит, но легко может затенять причину, по которой это происходит.

Как и в любом большом блоке кода, можно сделать свои намерения более ясными, если выполнить его декомпозицию и заменить фрагменты кода вызовами методов, имена которых раскрывают назначение соответствующего участка кода. Для кода с условными операторами выгода еще больше, если проделать это как для части, образующей условие, так и для всех альтернатив. Таким способом можно выделить условие и ясно обозначить, что лежит в основе ветвления. Кроме того, подчеркиваются причины организации ветвления.

## Техника

* Выделите условие в собственный метод.
* Выделите части «then» и «else» в собственные методы.

Сталкиваясь с вложенным условным оператором, я обычно смотрю сначала, не надо ли выполнить «Замену вложенных условных операторов граничным оператором» ([Replace Nested Conditional with Guard Clauses](/Replace-Nested-Conditional-with-Guard-Clauses.md)). Если в такой замене смысла нет, я провожу декомпози  цию каждого условного оператора.

## Пример

Допустим, требуется вычислить плату за какую то услугу, для кото  рой есть отдельный зимний и летний тариф:

```java 
if (date.before (SUMMER_START) || date.after(SUMMER_END))
    charge = quantity * _winterRate + _winterServiceCharge;
else charge = quantity * _summerRate;
```

Выделяю условие и каждую ветвь следующим образом:

```java
if (notSummer(date))
    charge = winterCharge(quantity);
else charge = summerCharge (quantity);
            
private boolean notSummer(Date date) {
    return date.before (SUMMER_START) || date.after(SUMMER_END);
}

private double summerCharge(int quantity) {
    return quantity * _summerRate;
}
    
private double winterCharge(int quantity) {
    return quantity * _winterRate + _winterServiceCharge;
}
```

Здесь для ясности показан конечный результат проведения рефакторинга. Однако на практике я провожу каждое выделение изолированно, выполняя после него компиляцию и тестирование.

Многие программисты в таких ситуациях не выделяют части, образующие условие. Часто условия кажутся короткими и не стоящими такого труда. Несмотря на краткость условия, нередко существует большой разрыв между смыслом кода и его телом. Даже в данном маленьком примере при чтении `notSummer(date)` я получаю более ясную информацию, чем из исходного кода. Если работать с оригиналом, приходится смотреть в код и разбираться в том, что он делает. В данном случае это сделать нетрудно, но даже здесь выделенный метод более похож на комментарий.